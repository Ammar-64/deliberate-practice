[![Gitpod ready-to-code](https://img.shields.io/badge/Gitpod-ready--to--code-blue?logo=gitpod)](https://gitpod.io/#https://github.com/ReCoded-Org/deliberate-practice)

# Case Study: Roman Numerals

## Learning Competencies

- read and understand unfamiliar code
- recognize recurring patterns in code
- demonstrate familiarity with the syntax of your target language
- execute and verify the performance of code against a strict specification
- build endurance for confusion and uncertainty
- demonstrate ability to engage in meaningful debate regarding code
- develop an awareness for performance implications and maintanance costs
- demonstrate the ability to create and execute a plan to build a software solution
- develop an appreciation for deeper study and sharing learning outcomes 

## Summary

Please refer to this challenge for context: https://rosettacode.org/wiki/Roman_numerals

This case study is intended to melt your brain a little.  So please be patient with yourself, your neighbor and the work while you get wildly curious about what's going on and don't stop til you drop -- whatever that means for your `#lifestyle`

You may want to try solving the original challenge first in any way you know how.  This will help shape the holes in your head for the round, square and other odd-shaped pieces you'll discover during this learning experience.

`[github]`
*Also note at the bottom of this gist there may be a statement like "X other files aren't shown".  This is a limitation of this github interface.  To see all the files just download (or clone) this gist to get access to all the files in this case study.*
`[/github]`

## Releases

Forget about the code for a second and let's consider process.  How do you plan to move through the 40+ solutions to the programming problem you're working on?  What's important?  What's not?

Experts know what to ignore.  That's a pretty important difference between them and a novice.  

It saves them a lot of time, so they get more done with less.

Try this:
1. Gather a group of people and pick a leader, mostly students but there can be other random people along for the ride.  it's fun.
2. Agree to move through this work together in a timed rhythm.  The rhythm is designed to force a series of struggles.
3. Some measure of playful faith might be required if you're the kind of person who prefers to control your own learning
4. Here's the rhythm: (40+ solutions * (5 sec + 50 sec) + 3 solutions * (5 * 60 sec)) = **50 mins total**
  - **for 5 seconds:** review each solution as quickly as possible.  look for visual anchors, patterns, data structures, etc.
  - **for 50 seconds:** review each solution long enough to classify it.  make up your own categories, compare and curate.
  - **for 5 minutes:** review the top 3 solutions more carefully.  how you sort for top 3 is another key question.
5. The cycle above can be repeated for other dimensions like swapping programming languages, machine constraints, pairing makeup, etc to help build a healthy heuristic for whatever your area of focus might be.  if the goal of the experience is to learn a second programming language quickly, then running this exercise through commong problems in familiar languages to the same problems in unfamiliar code will fill in many gaps quickly.  if the goal is self awareness then swapping pairs is great.
6. once the journey is complete you can pick your next ambitious target like writing an original solution
7. finally, the discussion is where a lot of the learning happens.  consider using a consistent, proven approach like [Thiagi's Six Step Debriefing process](https://ipjanuary2014.files.wordpress.com/2014/01/thiagis-debriefing-and-albatros-skit.pdf) so you can focus all your attention on the student experience and record observations for deeper mentorship.

The whole experience can last for as little as 1 hour or as long as a week depending on the number of cycles, targets and dimensions of learning intended by the group.

### Questions

Brainstorming on the following questions can be a good warmup activity as well.  They help frame the experience.

**establishing a baseline**
- does every solution run?  how can you verify this?
- do any solutions have bugs?  how can you verify this?

**breaking new ground**
- did you see any new syntax you didn't recognize?  any new operators, expressions or methods?
- can you decipher the syntax yourself from the context?
- will you use this new syntax in your next project?
- any new data structures?  what are they?

**recognizing patterns**
- how many fundamental solution patterns did you find?  
- how do you recognize them?  are you sure?  get worked up about it.

**working with patterns**
- what can you learn from these different perspectives?  are they really different?  if so, why?  debate.  get worked up about it.
- if you had to choose one, which one is the 'best' and why?  discuss with your pair if you have one.  

**considering optimizations**
consider the patterns you noticed in the code ...
- what are the performance implications of these patterns?  how can you verify this?
- what are the maintenance implications of these patterns?  how can you be sure?

**beginner's mind**
now that you've gone through all the above, open up a blank file and start again.
- what are you thinking about now?   as you plan your attack, what's most important?  as you consider options, what's least important?
- do you feel more or less confident than you did at first about your goal and ability to achieve it?  what's different?  discuss.
- does knowing so much about how others solved this challenge constrain your thinking?  if so, how can you reverse this effect?

## Optimize Your Learning

Some people seem to appreciate hearing these so here's a list of follow ups:

- document (and get ready to share) your aha! moments during this experience.  
- find a new pair-of-pairs to discuss your findings.  debate.  get worked up about it.
- find a teacher or mentor and ask them to review your work.  debate.  get worked up about it.
- write a blog post about what you've done here today.  now that you care so much, share it.

## Resources

If you're looking for a little hint on finding amazing resources, try this [surveying method](https://gist.github.com/amgando/9233425e956ac060c513) and see if it helps you somehow.

**More about solving the roman numerals challenge**
- test driven development
  - [Jim Weirich code kata](http://www.youtube.com/watch?v=983zk0eqYLY)
- solutions in various programming languages
  - [encoding](http://rosettacode.org/wiki/Roman_numerals/Encode)
  - [decoding](http://rosettacode.org/wiki/Roman_numerals/Decode)

**More about the value of reading code**
- http://www.skorks.com/2010/05/why-i-love-reading-other-peoples-code-and-you-should-too/
- http://en.wikipedia.org/wiki/Best_coding_practices
- http://rosettacode.org/wiki/Category:Programming_Tasks

**More about the value of case studies**
- http://en.wikipedia.org/wiki/Overlearning
- http://exchange.ac.uk/learning-and-teaching-theory-guide/deep-and-surface-approaches-learning.html
- http://www.cmu.edu/teaching/designteach/design/instructionalstrategies/casestudies.html
